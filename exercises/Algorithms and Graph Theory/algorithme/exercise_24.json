{
    "script": "Dans l'exercice donné aux étudiants, on considère la suite $(S_n)$ définie par\r\n$$S_n=\\sum_{k=0}^n \\frac{(-1)^k}{k+1}.$$\r\nOn a prouvé que $(S_n)$ converge vers une limite $\\ell$, et que, si on pose $u_n=S_{2n}$ et $v_n=S_{2n+1}$, alors pour tout entier $n$, on a $v_n\\leq \\ell\\leq u_n$. Il est demandé aux étudiants d'écrire un algorithme donnant un encadrement de $\\ell$ d'amplitude inférieur ou égal à $0.001$. Voici leurs réponses. Analysez-les.Étudiant 1 :n:=2u:=5/6v:=7/12Tant que u-v>0.001 faireu=u-1/(2n)+1/(2n+1)v=u-1/(2n+2)Fin Tant queRetourner u et v.Étudiant 2 :a=1c=1/2n=0b=ad=ctant que (a-c>0.001) fairen=n+1b=aa=b+(-1)/(2n+1)+1/(2n+2)d=cc=d+1/(2n+2)-1/(2n+3)Afficher a et bÉtudiant 3 :Entrées :u=1v=1/2n=0Traitement :Tant que (v-u>0.001)n=n+1u=u+somme{k=0 à 2n}(-1)^k/(k+1)v=v+somme{k=0 à 2n+1}(-1)^k/(k+1)Sortie : u,vÉtudiant 4 :Variables : u,v,n,kInitialisation :u=1v=1/2k=0n=0Traitement :Tant que (u-v>0.001) fairePour k allant de 1 à 2n faireu=u+(-1)^k/k+1Pour k allant de 1 à 2n+1 fairev=v+(-1)^k/(k+1)n=n+1Sortie : Afficher u,vÉtudiant 5 :Variables : a,b,n,u,vInitialisation :u=1v=1/2a=1/2b=1TraitementTant que (a>0.001)n=n+1a=1/(2n+2)b=1/(2n+1)u=v+bv=u-aSortie : u,vÉtudiant 6 :s=0t=0Pour k=0 à 1000 faires=s+(-1)^k/(k+1)Fin Pour.t=s+(-1)^(1001)/1002Afficher s,t",
    "hint": "",
    "solution": "Étudiant 1 :  l'initialisation est étrange (pourquoi initialiser au rang 2), mais pourquoi pas? Le test d'arrêt est correct, mais la valeur de $n$ n'est jamais changée. Les formules pour calculer u et v seraient correctes (ce qu'on vérifie en exécutant les premières itérations de la boucle) si on ajoutait $n=n+1$ avant la fin du Tant Que.Étudiant 2 : le test est correct, l'utilisation des variables $b$ et $d$ est superflue. Elle donne l'impression que l'étudiant n'a pas bien compris la notion de variable et ne sait pas que l'on peut faire $a=a+\\cdots$. Par ailleurs, le calcul de $a$ et de $c$ est erroné, comment le montre le calcul de la valeur de $u_1$. Enfin, les valeurs retournées ne doivent pas être $a$ et $b$, mais $a$ et $c$.Étudiant 3 : Bonne séparation des parties de l'algorithme (même s'il s'agit plus de la phase dite d'initialisation, ou de variables). On n'entre jamais dans la boucle (mauvais rôle joué par u et v). Dans la boucle, le calcul de u et v est erroné : ou bien on ne rajoute que les termes manquants, ou bien on calcule la somme, mais on ne l'ajoute pas à ce qui a déjà été calculé. De plus, on évite d'utiliser l'instruction somme dans un algorithme (elle n'est pas disponible dans tous les langages de programmation).Étudiant 4 : Bonne séparation des parties de l'algorithme et stratégie différente pour calculer la somme. Malheureusement, il faut réinitialiser les valeurs de u et de v à 0 au début du Tant Que pour que le calcul fonctionne, et la boucle sur $k$ devrait commencer en $0$ et non en $1$.Étudiant 5 : La variable $n$ n'est pas initialisée (il faudrait l'initialiser à $n=0$). Sinon, cela fonctionne. Le test est intéressant ainsi que la façon d'ajouter les termes. Là encore, pour se convaincre que l'algorithme fonctionne, il faut le simuler avec les premières itérations.Étudiant 6 : La démarche de cet étudiant est différente. Il calcule d'abord le nombre de termes de la série qu'il faut calculer pour avoir une bonne approximation. Pour cela, il remarque qu'il veut que $|u_n-v_n|\\leq 10^{-3}$ et que $|u_n-v_n|=\\frac 1{2n+2}$. Il suffit donc de calculer $u_n$ et $v_n$ avec $n\\geq 500$ pour avoir une bonne approximation. C'est ce que fait cet étudiant, qui calcule $S_{1000}=u_{500}$ et $S_{1001}=v_{500}$.",
    "lang": "french"
}